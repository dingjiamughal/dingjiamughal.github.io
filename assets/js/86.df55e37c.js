(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{62:function(e,t,s){"use strict";s.r(t);var n=s(0),i=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"content"},[t("h2",{attrs:{id:"_0619"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0619","aria-hidden":"true"}},[this._v("#")]),this._v(" 0619")]),t("p",[this._v("可能离串讲越来越近了，我还是好多不会，周末又玩掉了，今天赶紧来看看，中午之前把所有数据获取这部分看明白了")]),t("h2",{attrs:{id:"_0620"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0620","aria-hidden":"true"}},[this._v("#")]),this._v(" 0620")]),t("p",[this._v("了解了peerDependencies，这种情况只是用于写组件库的时候，必须把一些项目里会用到的库放在peerDependencies，否则再被引入的时候会报undefined。"),t("br"),this._v("\n原因是，比如vue，必须把vue模块单独抽出来，这时候在项目里引入vue或者引入组件库，组件库里引入的vue才是一个vue。webpack没办法做到统一识别，如果不peerDependencies那么将会产生这样的结果：组件库中指向内部的node_modules中的vue，项目里指向项目文件中的node_modules中的vue，所以peerDependencies是强行改变指针的作用")])])}],!1,null,null,null);t.default=i.exports}}]);